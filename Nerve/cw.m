function N_Na = cw(m, h, markovrates, Na_max, dt, hs)
%CW
    % global Nmh;
    Nmh = hs.Nmh;
    
    % Calculate transition rates of "escapes"
    zeta = [3*markovrates.am + markovrates.ah;...
            markovrates.bm + markovrates.ah + 2*markovrates.am;...
            2*markovrates.bm + markovrates.ah + markovrates.am;...
            3*markovrates.bm + markovrates.ah;...
            3*markovrates.am + markovrates.bh;...
            markovrates.bm + markovrates.bh + 2*markovrates.am;...
            2*markovrates.bm + markovrates.bh + markovrates.am;...
            3*markovrates.bm + markovrates.bh];

    % Vectors describing state transitions from current to next state
    p_trans_curr = [0,1,2,2,3,3,4,1,5,2,6,3,7,4,8,5,6,6,7,7,8];
    p_trans_next = [0,2,1,3,2,4,3,5,1,6,2,7,3,8,4,6,5,7,6,8,7];
        
    t_l_total = 0; % cumulative transition lifetime for this Euler time step
    
    
    M = [0,...
        3*markovrates.am,...
        markovrates.bm,...
        2*markovrates.am,...
        2*markovrates.bm,...
        markovrates.am,...
        3*markovrates.bm,...
        markovrates.ah,...
        markovrates.bh,...
        markovrates.ah,...
        markovrates.bh,...
        markovrates.ah,...
        markovrates.bh,...
        markovrates.ah,...
        markovrates.bh,...
        3*markovrates.am,...
        markovrates.bm,...
        2*markovrates.am,...
        2*markovrates.bm,...
        markovrates.am,...
        3*markovrates.bm];
    
    persistent T Q
    if isempty(T)
        T = 100;
        Q = ceil(1.1*T);
    end
    
    R = rand(Q,2); % gather randnomness
    
    i = 0;
    j = 0;
    
%     nmhind =  [1,2,2,3,3,4,1,5,2,6,3,7,4,8,5,6,6,7,7,8];

    while (t_l_total<=dt)
        
        i = i+1;
        j = j+1;
        
        if j > Q
            j = 1;
            R = rand(Q,2);
        end
                
        lambda = Nmh*zeta;
    
        % Determine transition lifetime
%         t_l = - log(rand(1)) / lambda; 
        t_l = - log(R(j,1)) / lambda; % 11x faster than previous line
            
        
        % Calculate cumulative transition lifetime
        t_l_total = t_l_total + t_l;
        
        % If cumulative transition lifetime is longer than the Euler time
        % step, then return number of channels presently in each state
        if (t_l_total>dt)
            
            break;
            
        end
        
        % Calculate cumulative probability distribution for state
        % transitions
%         P = cumsum([0,...
%             3*markovrates.am*Nmh(1),...
%             markovrates.bm*Nmh(2),...
%             2*markovrates.am*Nmh(2),...
%             2*markovrates.bm*Nmh(3),...
%             markovrates.am*Nmh(3),...
%             3*markovrates.bm*Nmh(4),...
%             markovrates.ah*Nmh(1),...
%             markovrates.bh*Nmh(5),...
%             markovrates.ah*Nmh(2),...
%             markovrates.bh*Nmh(6),...
%             markovrates.ah*Nmh(3),...
%             markovrates.bh*Nmh(7),...
%             markovrates.ah*Nmh(4),...
%             markovrates.bh*Nmh(8),...
%             3*markovrates.am*Nmh(5),...
%             markovrates.bm*Nmh(6),...
%             2*markovrates.am*Nmh(6),...
%             2*markovrates.bm*Nmh(7),...
%             markovrates.am*Nmh(7),...
%             3*markovrates.bm*Nmh(8)]/lambda);

%         N = [1, Nmh(p_trans_curr(2:end))]/lambda;


%         N = [1, Nmh(1), Nmh(2), Nmh(2), Nmh(3), Nmh(3), Nmh(4), Nmh(1), ...
%             Nmh(5), Nmh(2), Nmh(6), Nmh(3), Nmh(7), Nmh(4), Nmh(8), Nmh(5),...
%             Nmh(6), Nmh(6), Nmh(7), Nmh(7), Nmh(8)]/lambda; % faster than previous line
%         
%         P = cumsum(M.*N); % toto je nahrada za predchozi radky - je to rychlejsi
        
        N = [1, Nmh(1), Nmh(2), Nmh(2), Nmh(3), Nmh(3), Nmh(4), Nmh(1), ...
            Nmh(5), Nmh(2), Nmh(6), Nmh(3), Nmh(7), Nmh(4), Nmh(8), Nmh(5),...
            Nmh(6), Nmh(6), Nmh(7), Nmh(7), Nmh(8)]; % faster than previous line
        
        P = cumsum(M.*N) / lambda; % toto je nahrada za predchozi radky - je to rychlejsi

%         if sum(abs(P-PP)) > 100*eps
%             sum(abs(P-PP))
%         end
        
        % Determine which state transition has occurred
%         ind = find(rand(1)<P,1);
        ind = find(R(j,2)<P,1); % 2x faster than previous line
        
        Nmh(p_trans_curr(ind)) = Nmh(p_trans_curr(ind)) - 1; % decrease number of channels in current state
        Nmh(p_trans_next(ind)) = Nmh(p_trans_next(ind)) + 1; % increase number of channels in next state
        
    end
    
    T = (0.9*T + 0.1*i);
    Q = ceil(1.1*T);
        
    N_Na = Nmh(end);

    hs.Nmh = Nmh;

end

