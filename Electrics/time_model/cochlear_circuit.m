function [ circuit, OHC_V_rest, IHC_V_rest] = cochlear_circuit(mnaopt, plotflag, save_figures, args)
%COCHLEAR_CIRCUIT
arguments
    mnaopt (1,1) mnaOpt
    plotflag (1,1) logical = false
    save_figures (1,1) logical = false
    % args.connection char = 'mistrik'
    args.connection char = 'v3'
    % args.OHC_NLC_description char = 'linear'
    % args.OHC_NLC_description char = 'nonlinear'
    args.OHC_NLC_description char = 'nonlinear_freq'

    args.IHC_stereocilia_noise_damage (1,1) logical = false
    args.IHC_stereocilia_noise_damage_f0 (1,1) Frequency = Frequency(1200, 'Hz')
    args.IHC_stereocilia_noise_damage_degree (1,1) double = 0.1

    args.OHC_stereocilia_noise_damage (1,1) logical = false
    args.OHC_stereocilia_noise_damage_f0 (1,1) Frequency = Frequency(1200, 'Hz')
    args.OHC_stereocilia_noise_damage_degree (1,1) double = 0.1

end

default_tikz_options = { ...
    'relativeDataPath', 'img/HairCells/', ...
    'extraaxisoptions', 'legend style={font=\tiny}', ...
    'parseStrings', true};

%%

% linear function f(x=0) = a, f(x=1) = b.
linf = @(a, b, x) a + (b-a) * x;

%%
simulation_units = mnaopt.simulation_units;

sim_to_mV = Unit.conversionConstant(simulation_units.voltage, 'mV');
mV_to_sim = Unit.conversionConstant('mV', simulation_units.voltage);

xx = mnaopt.xgrid(:);
xgrid = mnaopt.xgrid(:);

%% Characteristic frequency model
% relationship between the spatial coordinate x and its characteristic frequency cf

[cx, cf] = characteristic_frequency_model(mnaopt.cf_model);

%% Endocohlear potential
% Vep is the potential difference between endolymph and perilymph
% It is used to estimate resting potentials for OHC and IHC,
% and it is the value of the Stria Vascularis Voltage Source
Vep = @(x) 90;
% Vep = @(x) 160;
% Vep = @(x) linf(90, 70, x);
% Vep = @(x) linf(70, 90, x);
% Vep = @(x) 0;
% Vep = @(x) linf(100, 80, x);

%% Nernst potential
% OHC potassium reversal potential [mV]
% EK_OHC = @(x) 0;
% EK_OHC = @(x) -75;
% EK_OHC = @(x) -80;
EK_OHC = @(x) linf(-90, -70, x);

% IHC potassium reversal potential [mV]
% EK_IHC = @(x) 0;
% EK_IHC = @(x) -70;
% EK_IHC = @(x) -75;
% EK_IHC = @(x) -80;
% EK_IHC = @(x) -90;
EK_IHC = @(x) linf(-100, -50, x);
% EK_IHC = @(x) linf(-90, -70, x);
% EK_IHC = @(x) linf(-80, -60, x);

%% Conductance & Resting potential estimate - OHC

assert(strcmp(mnaopt.OHC_MET_dependence, 'cilia'))
mech_ohc_var = 'OHC_cilia';

% OHC MET
[GAO, dGAO, GAO_pre, dGAO_pre] = OHC.METConductance( ...
    xgrid, simulation_units, ...
    'noise_damage', args.OHC_stereocilia_noise_damage, ...
    'noise_damage_f0', args.OHC_stereocilia_noise_damage_f0, ...
    'noise_damage_degree', args.OHC_stereocilia_noise_damage_degree, ...
    'plotflag', plotflag);

% OHC basolateral
switch mnaopt.OHC_basolateral_conductance_dependance
    case 'none'
        
    case {'vohc', 'vohc_ss'}
        version = 'Johnson_2011';
    case {'channel_popen', 'vohc_ss_v2'}
        % version = 'dev_v1';
        version = 'Tichacek_2022_v1';
end

[GBO, dGBO, GBO_pre, dGBO_pre, GBO_dep, GBO_pre_dep, ohc_channels] = OHC.BasolateralConductance( ...
    xgrid, simulation_units, ...
    'version', version, ...
    ...'version', 'dev_v1', ...
    ...'version', 'Johnson_2011', ...
    ...'version', 'LopezPoveda_2006', ...
    'plotflag', plotflag);

dep_rep = struct( ...
    'vihc', 'IHC', ...
    'vohc', 'OHC', ...
    'vihc_ss', 'IHC_ss', ...
    'vohc_ss', 'OHC_ss');

for i = 1:numel(ohc_channels)
    ohc_channels(i).voltage = dep_rep.(mnaopt.OHC_basolateral_popen_dependance);
end

mnaopt.OHC_basolateral_channels = ohc_channels;

% estimate resting potential
% xxx = linspace(0,1,10);
% xxx = xxx(:);
% yyy = zeros(size(xxx));
% 
% VO0 = linf(-50, 38, xxx);
% [OHC_V_rest, OHC_V_rest_int] = estimateRestingPotential( ...
%     GAO(xxx, yyy), ...
%     @(V) GBO(xxx, V*mV_to_sim), ...
%     Vep(xxx), EK, VO0, xxx);

OHC_V_rest_int = @(x) linf(-66.9, -47.6, x);

mnaopt.OHC_V_rest =  @(x) OHC_V_rest_int(x) * mV_to_sim;

%% Conductance & Resting potential estimate -  IHC

assert(strcmp(mnaopt.IHC_MET_dependence, 'BM'))
mech_ihc_var = 'BM_displ';

% IHC MET
[GAI, dGAI, GAI_pre, dGAI_pre, ...
    IHC_MET_popen_BM_mag_pre, IHC_G_max_pre] = IHC.METConductance( ...
    xgrid, simulation_units, ...
    ...'version', 'Jia_2007', ...
    'version', 'Tichacek_2022', ...
    'noise_damage', args.IHC_stereocilia_noise_damage, ...
    'noise_damage_f0', args.IHC_stereocilia_noise_damage_f0, ...
    'noise_damage_degree', args.IHC_stereocilia_noise_damage_degree, ...
    'plotflag', plotflag);

% IHC basolateral
switch mnaopt.IHC_basolateral_conductance_dependance
    case 'none'
        
    case {'vihc', 'vihc_ss'}
        version = 'Johnson_2015';
    case 'channel_popen'
        version = 'LopezPoveda_2006';
    case 'channel_popen_Dierich_2020'
        version = 'Dierich_2020';
    case {'channel_popen_tonotopic', 'vihc_ss_v2'}
        ... version = 'LopezPoveda_2006_Johnson_2015';
        version = 'Tichacek_2022_v1';
end

[GBI, dGBI, GBI_pre, dGBI_pre, GBI_dep, GBI_pre_dep, ihc_channels, EK_gradient_IHC] = IHC.BasolateralConductance( ...
    xgrid, simulation_units, ...
    'version', version, ...
    ...'version', 'Johnson_2015', ...
    ...'version', 'LopezPoveda_2006', ...
    'plotflag', plotflag);

EK_IHC = @(x) linf(EK_gradient_IHC(1), EK_gradient_IHC(2), x);

for i = 1:numel(ihc_channels)
    ihc_channels(i).voltage = dep_rep.(mnaopt.IHC_basolateral_popen_dependance);
end

mnaopt.IHC_basolateral_channels = ihc_channels;

% estimate resting potential
% V0 = -59*ones(size(xxx));
% IHC_V_rest = estimateRestingPotential( ...
%     GAI(xxx, yyy), ...
%     @(V) GBI(V*mV_to_sim), ...
%     Vep(xxx), EK, V0);

% [IHC_V_rest, ~, ~] = IHC.RestingPotential(xgrid, simulation_units);
IHC_V_rest = @(x) linf(-64, -54, x);

mnaopt.IHC_V_rest = @(x) IHC_V_rest(x) * mV_to_sim;

%% Capacitance

% IHC
[CAI, CBI, hfig_rest] = IHC.Capacitance( ...
    xx, simulation_units, ...
    'version', 'Johnson_2015', 'plotflag', plotflag);

% OHC
[CAO, CBO, hfig] = OHC.Capacitance( ...
    xx, simulation_units, ...
    'description', args.OHC_NLC_description, ...
    'plotflag', plotflag);

if save_figures
    mySaveFig(hfig, 'OHC_nonlinear_capacitance', [], 'Results/HairCells/', default_tikz_options{:});
end

if plotflag
    % hfig = figure;
    hfig = figure(hfig_rest);
    hold on
    
    dV = 20; % mV
    
    V_rest = OHC_V_rest_int(xx) * mV_to_sim;
    V_dep = V_rest + dV * mV_to_sim;
    V_hyp = V_rest - dV * mV_to_sim;
    
    C_rest = CBO.dep_fun{1}{1}(xx, V_rest);
    C_dep = CBO.dep_fun{1}{1}(xx, V_dep);
    C_hyp = CBO.dep_fun{1}{1}(xx, V_hyp);
    
    C = CBO.dep_fun{1}{1}(xx, V_rest) + CAO.dep_fun{1}{1}(xx);
    
    plot(xx, C, 'r');
    
    shadedErrorBar(xx, C_rest, [C_dep-C_rest, -C_hyp+C_rest], ...
            'lineProps', {'Color', 'r'}, ...
            'edgeLines', true, ...
            'patchSaturation', 0.1)
    
    k = 0.70;
    n = round(k*numel(xx));
    
    plot([xx(n), xx(n), xx(n)], [C_dep(n), C_rest(n), C_hyp(n)], 'k-o');
    text(k - 0.01, mean([C_dep(n),C_rest(n)]), ...
        sprintf('dV = +%d mV', dV), ...
        'HorizontalAlignment', 'right')
    text(k - 0.01, mean([C_hyp(n),C_rest(n)]), ...
        sprintf('dV = -%d mV', dV), ...
        'HorizontalAlignment', 'right')
    
    text(k + 0.01, mean([C_dep(n),C_rest(n)]), ...
        sprintf('dC = %.0f %%', 100*(C_dep(n)-C_rest(n))/C_rest(n)))
    text(k + 0.01, mean([C_hyp(n),C_rest(n)]), ...
        sprintf('dC = %.0f %%', 100*(C_hyp(n)-C_rest(n))/C_rest(n)))
    
    xlabel('rel. distance from base')
    ylabel('capacitance [pF]')
    
    if save_figures
        mySaveFig(hfig, 'OHC_basolateral_capacitance', [], 'Results/HairCells/', default_tikz_options{:});
    end
end
            
% if plotflag
%     figure
%     tiledlayout('flow')
%     nexttile
%     hold on
%     plot(V, NLC_rel(V), 'k');
%     scatter(OHC_V_rest_int(xgrid), NLC_rel(OHC_V_rest_int(xgrid)), [], xgrid)
%     nexttile
%     hold on
%     plot(V, NLC_rel(V), 'k');
%     scatter(OHC_V_rest_int(xgrid)+10, NLC_rel(OHC_V_rest_int(xgrid)+10), [], xgrid)
%     nexttile
%     hold on
%     plot(V, NLC_rel(V), 'k');
%     scatter(OHC_V_rest_int(xgrid)-10, NLC_rel(OHC_V_rest_int(xgrid)-10), [], xgrid)
% 
% 
% 
%     OHC_capacitance_basal_max = @(x) capacitance_basal(x) ./ NLC_rel(OHC_V_rest_int(x));
% 
%     OHC_capacitance_basal_nonlin = @(x,V) OHC_capacitance_basal_max(x) .* NLC_rel(V);
% 
%     figure
%     hold on
%     plot(xgrid, OHC_capacitance_basal_max(xgrid))
%     % plot(xx, OHC_capacitance_basal(xx))
%     plot(xgrid, OHC_capacitance_basal_nonlin(xgrid, OHC_V_rest_int(xgrid)), 'DisplayName', 'resting')
%     plot(xgrid, OHC_capacitance_basal_nonlin(xgrid, OHC_V_rest_int(xgrid)+10), 'DisplayName', 'resting + 10')
%     plot(xgrid, OHC_capacitance_basal_nonlin(xgrid, OHC_V_rest_int(xgrid)-10), 'DisplayName', 'resting - 10')
% 
%     legend()
% end

%% time constant - OHC & IHC

fohc.Ca = @(x) Capacitance(OHC_capacitance_apical(x), 'pF');
fohc.Cb = @(x) Capacitance(OHC_capacitance_basal(x), 'pF');

fihc.Ca = @(x) Capacitance(IHC_capacitance_apical(x), 'pF');
fihc.Cb = @(x) Capacitance(IHC_capacitance_basal(x), 'pF');


fohc.Ga = @(x,y) Conductance(GAO(x) .* OHC.met_popen(y), 'nS');
fohc.Gb = @(x,V) Conductance(GBO(x,V * mV_to_sim), 'nS');

fihc.Ga = @(x,y) Conductance(GAI(x,y), 'nS');
fihc.Gb = @(x,V) Conductance(GBI(x,V * mV_to_sim), 'nS');


fohc.tau = @(x,y,V) Time((fohc.Ca(x).nF + fohc.Cb(x).nF)./(fohc.Ga(x,y).nS + fohc.Gb(x,V).nS), 's');
fihc.tau = @(x,y,V) Time((fihc.Ca(x).nF + fihc.Cb(x).nF)./(fihc.Ga(x,y).nS + fihc.Gb(x,V).nS), 's');

fohc.f3db = @(x,y,V) 1./(2*pi*fohc.tau(x,y,V));
fihc.f3db = @(x,y,V) 1./(2*pi*fihc.tau(x,y,V));


% Assuming we have something like:
% tau * dV/dt + V = A e^(j * omega * t)
% we can calculate the magnitude V_inf as
% V_inf = A / sqrt( 1 + (omega * tau)^2 )    

fohc.magnitude = @(x,y,V) 1./sqrt(1 + (2*pi* cf(x) .* fohc.tau(x,y,V).s).^2);
fihc.magnitude = @(x,y,V) 1./sqrt(1 + (2*pi* cf(x) .* fihc.tau(x,y,V).s).^2);

fohc.phase_shift = @(x,y,V) -atan(2*pi* cf(x) .* fohc.tau(x,y,V).s);
fihc.phase_shift = @(x,y,V) -atan(2*pi* cf(x) .* fihc.tau(x,y,V).s);

%% Plot - OHC & IHC conductance

if plotflag && false
    hfig = figure;
    hold on
    xx = mnaopt.xgrid;
    yy = zeros(size(xx));
    
    plot(xx, GBO(xx,OHC_V_rest_int(xx)*mV_to_sim), 'Color', 'r')
    % plot(xx, GAO(xx,yy).*OHC.met_popen(xx), 'Color', 'r', 'LineStyle', '--')
    
    plot(xx, GBI(xx, mnaopt.IHC_V_rest(xx)), 'Color', 'b')
    plot(xx, GAI(xx,yy), 'Color', 'b', 'LineStyle', '--')

   
    legend({'OHC basolateral', 'OHC apical', 'IHC basolateral', 'IHC apical'})
    title('conductance at rest');
    xlabel('Distance from stapes (norm.)');
    ylabel('G [nS]');
    
    if save_figures
        mySaveFig(hfig, 'HC_G_rest', [], 'Results/HairCells/', default_tikz_options{:});
    end
end

%% Plot - OHC & IHC resting potential estimate

% Plot IHC/OHC resting potential estimate and corresponding steady-state conductance
if plotflag
    hfig = figure;
    hold on
    plot(xx, OHC_V_rest_int(xx), 'Color', 'r');
    plot(xx, IHC_V_rest(xx), 'Color', 'b');
    legend({'OHC', 'IHC'})
    xlabel('Distance from stapes (norm.)')
    ylabel('Estimated resting voltage')

    if save_figures
        mySaveFig(hfig, 'HC_V_rest', [], 'Results/HairCells/', default_tikz_options{:});
    end   
end

%% Time constants

if false
    hfig = figure;
    hold on
    
    yy = zeros(size(xx));
    
    % OHC
    
    CA = Capacitance(OHC_capacitance_apical(xx), 'pF');
    CB = Capacitance(OHC_capacitance_basal(xx), 'pF');
    
    GA = Conductance(GAO(xx).*OHC.met_popen(yy), 'nS');
    GB = Conductance(GBO(xx,OHC_V_rest_int(xx)*mV_to_sim), 'nS');
    
    TC = Time((CA.nF + CB.nF)./(GA.nS + GB.nS), 's'); % this is according to Johnson, but maybe should be G = 1/(1/GB + 1/GA) ?
    % TC = Time((CA.nF + CB.nF).*(1./GA.nS + 1./GB.nS), 's');
    
    TCapical = Time(CA.nF./GA.nS, 's');
    TCbasal = Time(CB.nF./GB.nS, 's');
    
    plot(xx, TC.ms, 'Color', 'r', 'LineStyle', '-')
    plot(xx, TCapical.ms, 'Color', 'r', 'LineStyle', '--')
    plot(xx, TCbasal.ms, 'Color', 'r', 'LineStyle', ':')

    % IHC
    
    CA = Capacitance(IHC_capacitance_apical(xx), 'pF');
    CB = Capacitance(IHC_capacitance_basal(xx), 'pF');
    
    GA = Conductance(GAI_max(xx).*IHC.met_popen(xx,yy), 'nS');
    GB = Conductance(GBI(xx, mnaopt.IHC_V_rest(xx)), 'nS');
    
    TC = Time((CA.nF + CB.nF)./(GA.nS + GB.nS), 's'); % this is according to Johnson, but maybe should be G = 1/(1/GB + 1/GA) ?
    % TC = Time((CA.nF + CB.nF).*(1./GA.nS + 1./GB.nS), 's');
    
    ihc.tau = TC;
    ihc.f3db = 1./(2*pi*TC);
    
    TCapical = Time(CA.nF./GA.nS, 's');
    TCbasal = Time(CB.nF./GB.nS, 's');
    
    plot(xx, TC.ms, 'Color', 'b', 'LineStyle', '-')
    plot(xx, TCapical.ms, 'Color', 'b', 'LineStyle', '--')
    plot(xx, TCbasal.ms, 'Color', 'b', 'LineStyle', ':')
    
    plot(IHC.Johnson_2015.time_constant.x, IHC.Johnson_2015.time_constant.tau.ms, 'bo');
    
    yl = get(gca, 'ylim');
    
    % cf
    T_cf = 1./Frequency(cf(xx), 'Hz');
    plot(xx, T_cf.ms, 'Color', 'k', 'LineStyle', '-')
    
    legend({'OHC T', 'OHC T apical', 'OHC T basal', ...
            'IHC T', 'IHC T apical', 'IHC T basal', ...
            'IHC Johnson 2016', ...
            'char. time'}, ...
            'Location', 'NorthWest')
    title('HC Time Constant');
    xlabel('Distance from stapes (norm.)');
    ylabel('T [ms]');
    
    ylim(yl);
    
    if save_figures
        mySaveFig(hfig, 'HC_time_constant', [], 'Results/HairCells/', default_tikz_options{:});
    end
    
    
    VI0 = mnaopt.IHC_V_rest(xx) * sim_to_mV;
    VO0 = mnaopt.OHC_V_rest(xx) * sim_to_mV;
    y0 = zeros(size(xx));
    
    hfig = figure;
    hold on
    
    % CHECK THIS:
    % stereocilia bend in the + direction
    % => MET conductance increases
    %  => cations flow in
    %   => membrane is depolarized
    %    => potential increases (e.g. from -50 to -40 mV)
    %     => basolateral conductance increases
    %     => capacitance decreases
    
    %
    % => dy positive & dV positive
    % => dy negative & dV negative
    
    % dV = 10; % mV
    % dy = 100; % nm
    ddV = 0.1 * 2.^(3:7);
    ddy = 10 * ddV;
    
    %ddy = zeros(size(ddV));
    %ddV = zeros(size(ddy));
    
    edgeLines = false;
    patchSaturation = 0.05;
    
    for i = 1:numel(ddy)
    
        dy = ddy(i);
        dV = ddV(i);
        
        m = fohc.f3db(xx, y0, VO0).Hz;
        p = fohc.f3db(xx, y0 + dy, VO0 + dV).Hz;
        q = fohc.f3db(xx, y0 - dy, VO0 - dV).Hz;

        shadedErrorBar(xx, m, [p-m;-q+m], ...
            'lineProps', {'Color', 'r', 'DisplayName', sprintf('OHC + %d nm + %g mV', dy, dV)}, ...
            'edgeLines', edgeLines, ...
            'patchSaturation', patchSaturation)

        m = fihc.f3db(xx, y0, VI0).Hz;
        p = fihc.f3db(xx, y0 + dy, VI0 + dV).Hz;
        q = fihc.f3db(xx, y0 - dy, VI0 - dV).Hz;

        shadedErrorBar(xx, m, [p-m;-q+m], ...
            'lineProps', {'Color', 'b', 'DisplayName', sprintf('IHC + %d nm + %g mV', dy, dV)}, ...
            'edgeLines', edgeLines, ...
            'patchSaturation', patchSaturation)
        
    end
    
    plot(xx, cf(xx), 'DisplayName', 'CF', ...
        'Color', 'k', 'LineStyle', '-')
    
    
    set(gca, 'Yscale', 'log')
    legend('Location', 'NorthEast')
    title('HC Corner frequency');
    xlabel('Distance from stapes (norm.)');
    ylabel('frequency (Hz)');
    ylim([50, 20e3])
    
    if save_figures
        mySaveFig(hfig, 'HC_corner_frequency', [], 'Results/HairCells/', default_tikz_options{:});
    end
    
    hfig = figure;
    hold on
    
    for i = 1:numel(ddy)
    
        dy = ddy(i);
            dV = ddV(i);

        m = fohc.magnitude(xx, y0, VO0);
        p = fohc.magnitude(xx, y0 + dy, VO0 + dV);
        q = fohc.magnitude(xx, y0 - dy, VO0 - dV);

        shadedErrorBar(xx, 100*m, 100*[p-m;-q+m], ...
            'lineProps', {'Color', 'r', 'DisplayName', sprintf('OHC + %d nm + %g mV', dy, dV)}, ...
            'edgeLines', edgeLines, ...
            'patchSaturation', patchSaturation)

        m = fihc.magnitude(xx, y0, VI0);
        p = fihc.magnitude(xx, y0 + dy, VI0 + dV);
        q = fihc.magnitude(xx, y0 - dy, VI0 - dV);

        shadedErrorBar(xx, 100*m, 100*[p-m;-q+m], ...
            'lineProps', {'Color', 'b', 'DisplayName', sprintf('IHC + %d nm + %g mV', dy, dV)}, ...
            'edgeLines', edgeLines, ...
            'patchSaturation', patchSaturation)    
    end
    
    legend('Location', 'NorthWest')
    title('Magnitude of response');
    xlabel('Distance from stapes (norm.)');
    ylabel('rel. magnitude [%]');
    
    if save_figures
        mySaveFig(hfig, 'HC_magnitude_attenuation', [], 'Results/HairCells/', default_tikz_options{:});
    end
    
    hfig = figure;
    hold on
    
    for i = 1:numel(ddy)
    
        dy = ddy(i);
            dV = ddV(i);

        m = fohc.phase_shift(xx, y0, VO0);
        p = fohc.phase_shift(xx, y0 + dy, VO0 + dV);
        q = fohc.phase_shift(xx, y0 - dy, VO0 - dV);

        shadedErrorBar(cf(xx), 100*m, 100*[p-m;-q+m], ...
            'lineProps', {'Color', 'r', 'DisplayName', sprintf('OHC + %d nm + %g mV', dy, dV)}, ...
            'edgeLines', edgeLines, ...
            'patchSaturation', patchSaturation)

        m = fohc.phase_shift(xx, y0, VI0);
        p = fohc.phase_shift(xx, y0 + dy, VI0 + dV);
        q = fohc.phase_shift(xx, y0 - dy, VI0 - dV);

        shadedErrorBar(cf(xx), 100*m, 100*[p-m;-q+m], ...
            'lineProps', {'Color', 'b', 'DisplayName', sprintf('IHC + %d nm + %g mV', dy, dV)}, ...
            'edgeLines', edgeLines, ...
            'patchSaturation', patchSaturation)    
    end
    
    legend('Location', 'NorthEast')
    title('Phase shift');
    xlabel('Frequency (Hz)');
    ylabel('phase shift [deg]');
    
    if save_figures
        mySaveFig(hfig, 'HC_phase_shift', [], 'Results/HairCells/', default_tikz_options{:});
    end
end
            
            
%% Setting up the electric circuit
% see Mistrik et al.: A model of 3D current...(2009)
% Fig 1/b for the approximate layout of the circuit

% number of OHC represented by a single circuit
num_ohc_per_cs = mnaopt.num_ohc_per_cs; 

%% Resistors

conductance_si_unit = 'S';
conductance_unit = 'nS';
resistors = struct(); % [values in nS]

if true
    resistors.RAI = ...
        { 'name', 'RAI', ...          % IHC, Apical
            'special', 'radial', ...
            'ref_value', 1, ...
            'dep', {{'xpos', mech_ihc_var}}, ...
            'dep_fun', {{GAI}}, ...
            'dep_fun_der', {{dGAI}}, ...
            'dep_fun_args', {{{'xpos',mech_ihc_var}}}, ...
            'dep_fun_der_respect', {{mech_ihc_var}}, ...
            'pre', struct( ...
                'dep_fun', struct( ...
                    'fun', GAI_pre, ...
                    'args', {{mech_ihc_var}}), ...
                'dep_fun_der', struct( ...
                    'fun', dGAI_pre, ...
                    'args', {{mech_ihc_var}})), ...
        };
else % attempt on random channels
    resistors.RAI = ...
        { 'name', 'RAI', ...          % IHC, Apical
            'special', 'radial', ...
            'ref_value', 1, ...
            'dep', {{'xpos', mech_ihc_var}}, ...
            'dep_fun', {{GAI}}, ...
            'dep_fun_der', {{dGAI}}, ...
            'dep_fun_args', {{{'xpos',mech_ihc_var}}}, ...
            'dep_fun_der_respect', {{mech_ihc_var}}, ...
            'pre', struct( ...
                'dep_fun', struct( ...
                    'fun', @(y) IHC_G_max_pre .* rand_open(IHC_MET_popen_BM_mag_pre(y, ones(size(y))), 50), ...
                    'args', {{mech_ihc_var}}), ...
                'dep_fun_der', struct( ...
                    'fun', dGAI_pre, ...
                    'args', {{mech_ihc_var}})), ...
        }; 
end

switch mnaopt.IHC_basolateral_conductance_dependance 
    
    case {'channel_popen', 'channel_popen_tonotopic', 'channel_popen_Dierich_2020'}
        
        RBI_leak = @(x) linf(1, 1, x);
        resistors.RBI_leak = ...
            { 'name', 'RBI_leak', ...            % Spiral Limbus
                'special', 'radial', ...
                'ref_value', 1, ...
                'dep', {{'xpos'}}, ...
                'dep_fun', {{RBI_leak}}, ...
                'dep_fun_args', {{{'xpos'}}}, ...
            };

        for i = 1:numel(mnaopt.IHC_basolateral_channels)
            GBI_dep{i} = replace_dependance('popen', sprintf('popen_%s', mnaopt.IHC_basolateral_channels(i).name), GBI_dep{i});
            GBI_pre_dep{i} = replace_dependance('popen', sprintf('popen_%s', mnaopt.IHC_basolateral_channels(i).name), GBI_pre_dep{i});
        
            rname = sprintf('RBI_%s', mnaopt.IHC_basolateral_channels(i).name);
            
            resistors.(rname) = ...
                { 'name', rname, ...          % IHC, Basal
                    'special', 'radial', ...
                    'ref_value', 1, ...
                    'dep', {GBI_dep{i}}, ...
                    'dep_fun', {{GBI{i}}}, ...
                    'dep_fun_der', {{dGBI{i}}}, ...
                    'dep_fun_args', {{GBI_dep{i}}}, ...
                    'dep_fun_der_respect', {{sprintf('popen_%s', mnaopt.IHC_basolateral_channels(i).name)}}, ...
                    'pre', struct( ...
                        'dep_fun', struct( ...
                            'fun', GBI_pre{i}, ...
                            'args', {GBI_pre_dep{i}}), ...
                        'dep_fun_der', struct( ...
                            'fun', dGBI_pre{i}, ...
                            'args', {GBI_pre_dep{i}})), ...
                };
        end
    case 'vihc'
        
        GBI_dep = replace_dependance('voltage', 'vihc', GBI_dep);
        GBI_pre_dep = replace_dependance('voltage', 'vihc', GBI_pre_dep);
        
        resistors.RBI = ...
            { 'name', 'RBI', ...          % IHC, Basal
                'special', 'radial', ...
                'ref_value', 1, ...
                'dep', {GBI_dep}, ...
                'dep_fun', {{GBI}}, ...
                'dep_fun_der', {{dGBI}}, ...
                'dep_fun_args', {{GBI_dep}}, ...
                'dep_fun_der_respect', {{'vihc'}}, ...
                'pre', struct( ...
                    'dep_fun', struct( ...
                        'fun', GBI_pre, ...
                        'args', {GBI_pre_dep}), ...
                    'dep_fun_der', struct( ...
                        'fun', dGBI_pre, ...
                        'args', {GBI_pre_dep})), ...
            };
    case 'vihc_ss'
        
        GBI_dep = replace_dependance('voltage', 'vihc_ss', GBI_dep);
        GBI_pre_dep = replace_dependance('voltage', 'vihc_ss', GBI_pre_dep);
        
        resistors.RBI = ...
            { 'name', 'RBI', ...          % IHC, Basal
                'special', 'radial', ...
                'ref_value', 1, ...
                'dep', {GBI_dep}, ...
                'dep_fun', {{GBI}}, ...
                'dep_fun_args', {{GBI_dep}}, ...
                'pre', struct( ...
                    'dep_fun', struct( ...
                        'fun', GBI_pre, ...
                        'args', {GBI_pre_dep})), ...
            };
    otherwise
        error('Unknown option %s', mnaopt.IHC_basolateral_conductance_dependance );
end

resistors.RAO = ...
    { 'name', 'RAO', ...          % OHC, Apical
        'special', 'radial', ...
        'ref_value', num_ohc_per_cs, ...
        'dep', {{'xpos', mech_ohc_var}}, ...
        'dep_fun', {{GAO}}, ...
        'dep_fun_der', {{dGAO}}, ...
        'dep_fun_args', {{{'xpos', mech_ohc_var}}}, ...
        'dep_fun_der_respect', {{mech_ohc_var}}, ...
        'pre', struct( ...
            'dep_fun', struct( ...
                'fun', GAO_pre, ...
                'args', {{mech_ohc_var}}), ...
            'dep_fun_der', struct( ...
                'fun', dGAO_pre, ...
                'args', {{mech_ohc_var}})), ...
    };

switch mnaopt.OHC_basolateral_conductance_dependance
    case 'channel_popen'
        
        RBO_leak = @(x) linf(1, 1, x);
        resistors.RBO_leak = ...
            { 'name', 'RBO_leak', ...            % Spiral Limbus
                'special', 'radial', ...
                'ref_value', num_ohc_per_cs, ...
                'dep', {{'xpos'}}, ...
                'dep_fun', {{RBO_leak}}, ...
                'dep_fun_args', {{{'xpos'}}}, ...
            };

        for i = 1:numel(mnaopt.OHC_basolateral_channels)
            GBO_dep{i} = replace_dependance('popen', sprintf('popen_%s', mnaopt.OHC_basolateral_channels(i).name), GBO_dep{i});
            GBO_pre_dep{i} = replace_dependance('popen', sprintf('popen_%s', mnaopt.OHC_basolateral_channels(i).name), GBO_pre_dep{i});
        
            rname = sprintf('RBO_%s', mnaopt.OHC_basolateral_channels(i).name);
            
            resistors.(rname) = ...
                { 'name', rname, ...          % OHC, Basal
                    'special', 'radial', ...
                    'ref_value', num_ohc_per_cs, ...
                    'dep', {GBO_dep{i}}, ...
                    'dep_fun', {{GBO{i}}}, ...
                    'dep_fun_der', {{dGBO{i}}}, ...
                    'dep_fun_args', {{GBO_dep{i}}}, ...
                    'dep_fun_der_respect', {{sprintf('popen_%s', mnaopt.OHC_basolateral_channels(i).name)}}, ...
                    'pre', struct( ...
                        'dep_fun', struct( ...
                            'fun', GBO_pre{i}, ...
                            'args', {GBO_pre_dep{i}}), ...
                        'dep_fun_der', struct( ...
                            'fun', dGBO_pre{i}, ...
                            'args', {GBO_pre_dep{i}})), ...
                };
        end
    case 'vohc'
        resistors.RBO = ...
            { 'name', 'RBO', ...          % OHC, Basal
                'special', 'radial', ...
                'ref_value', num_ohc_per_cs, ...
                'dep', {{'xpos','vohc'}}, ...
                'dep_fun', {{GBO}}, ...
                'dep_fun_der', {{dGBO}}, ...
                'dep_fun_args', {{{'xpos','vohc'}}}, ...
                'dep_fun_der_respect', {{'vohc'}}, ...
                'pre', struct( ...
                    'dep_fun', struct( ...
                        'fun', GBO_pre, ...
                        'args', {{'vohc'}}), ...
                    'dep_fun_der', struct( ...
                        'fun', dGBO_pre, ...
                        'args', {{'vohc'}})), ...
            };
    case 'vohc_ss'
        resistors.RBO = ...
            { 'name', 'RBO', ...          % OHC, Basal
                'special', 'radial', ...
                'ref_value', num_ohc_per_cs, ...
                'dep', {{'xpos', 'vohc_ss'}}, ...
                'dep_fun', {{GBO}}, ...
                'dep_fun_args', {{{'xpos', 'vohc_ss'}}}, ...
                'pre', struct( ...
                    'dep_fun', struct( ...
                        'fun', GBO_pre, ...
                        'args', {{'vohc_ss'}})), ...
            };
    otherwise
        error('Unknown option %s', mnaopt.OHC_basolateral_conductance_dependance );
end

ff = 100;
%GStV = @(x) linf(100, 1000, x);
GStV = @(x) linf(1000*ff, 1000*ff, x);
resistors.RStV = ...
    { 'name', 'RStV', ...          % Stria Vascularis
        'special', 'radial', ...
        'dep', {{'xpos'}}, ...
        'dep_fun', {{GStV}}, ...
        'dep_fun_args', {{{'xpos'}}}, ...
    };

ff = 100;
GSL = @(x) linf(1000*ff, 1000*ff, x);
resistors.RSL = ...
    { 'name', 'RSL', ...            % Spiral Limbus
        'special', 'radial', ...
        'ref_value', 1, ...
        'dep', {{'xpos'}}, ...
        'dep_fun', {{GSL}}, ...
        'dep_fun_args', {{{'xpos'}}}, ...
    };

ff = 100;
GOC = @(x) linf(1000*ff, 1000*ff, x);
resistors.ROC = ...
    { 'name', 'ROC', ...          % overall Organ of Corti resistance (of the cross sections)
        'special', 'radial', ...
        'ref_value', 1, ...
        'dep', {{'xpos'}}, ...
        'dep_fun', {{GOC}}, ...
        'dep_fun_args', {{{'xpos'}}}, ...
    };

% REISSNER'S MEMBRANE

% Strelioff 1973 has 28.5 - 25.5 kOhm per mm of cros-section
%   - our cochlea is 33.5 mm long
%     with 3000 cross-sections

% in nS:
% R1 = 1e9 / 28.5e3 * 33.5 / 3000
%    = 391.8129 nS per cross-section
% R2 = 1e9 / 25.5e3 * 33.5 / 3000
%    = 437.9085 nS per cross-section

GRM = @(x) linf(391.8129, 437.9085, x);

resistors.RRM = ...
    { 'name', 'RRM', ...
        'special', 'radial', ...
        'ref_value', 1, ...
        'dep', {{'xpos'}}, ...
        'dep_fun', {{GRM}}, ...
        'dep_fun_args', {{{'xpos'}}}, ...
    };

% SV-SL MEMBRANE
%     = R1 in Strelioff
% Strelioff 1973 has 6.5 - 14.5 kOhm per mm of cros-section
%   - our cochlea is 33.5 mm long
%     with 3000 cross-sections

% in nS:
% R1 = 1e9 / 6.5e3 * 33.5 / 3000
%    = 1717.9 nS per cross-section
% R2 = 1e9 / 14.5e3 * 33.5 / 3000
%    = 770.1149 nS per cross-section

GSVSL = @(x) linf(1717.9, 770.1149, x);

resistors.RSVSL = ...
    { 'name', 'RSVSL', ...
        'special', 'radial', ...
        'ref_value', 1, ...
        'dep', {{'xpos'}}, ...
        'dep_fun', {{GSVSL}}, ...
        'dep_fun_args', {{{'xpos'}}}, ...
    };

% SM-SL MEMBRANE
%     = R6 in Strelioff
% Strelioff 1973 has 24 - 30 kOhm per mm of cros-section
%   - our cochlea is 33.5 mm long
%     with 3000 cross-sections

% in nS:
% R1 = 1e9 / 24e3 * 33.5 / 3000
%    = 465.3 nS per cross-section
% R2 = 1e9 / 30e3 * 33.5 / 3000
%    = 372.2 nS per cross-section

GSMSL = @(x) linf(465.3, 372.2, x);

resistors.RSMSL = ...
    { 'name', 'RSMSL', ...
        'special', 'radial', ...
        'ref_value', 1, ...
        'dep', {{'xpos'}}, ...
        'dep_fun', {{GSMSL}}, ...
        'dep_fun_args', {{{'xpos'}}}, ...
    };

% ST-SL MEMBRANE
%     = R5 in Strelioff
% Strelioff 1973 has 1.5 - 3.0 kOhm per mm of cros-section
%   - our cochlea is 33.5 mm long
%     with 3000 cross-sections

% in nS:
% R1 = 1e9 / 1.5e3 * 33.5 / 3000
%    = 7.4444e+03 nS per cross-section
% R2 = 1e9 / 3.0e3 * 33.5 / 3000
%    = 3.7222e+03 nS per cross-section

GSTSL = @(x) linf(7.444e3, 3.722e+03, x);

resistors.RSTSL = ...
    { 'name', 'RSTSL', ...
        'special', 'radial', ...
        'ref_value', 1, ...
        'dep', {{'xpos'}}, ...
        'dep_fun', {{GSTSL}}, ...
        'dep_fun_args', {{{'xpos'}}}, ...
    };

% BASILAR MEMBRANE

resistors.RBM = ...
    { 'name', 'RBM', ...
        'special', 'radial', ...
        'ref_value', 1000, ...
    };

%% Longitudinal resistors

% SCALA MEDIA
%     = R9 in Strelioff
% Strelioff 1973 has 8 - 20 kOhm per mm of cros-section
%   - our cochlea is 33.5 mm long
%     with 3000 cross-sections

% in nS:
% R1 = 1e9 / (8e3 * 33.5 / 3000)
%    = 11.194e6 nS per cross-section
% R2 = 1e9 / (18e3 * 33.5 / 3000)
%    = 4.9751e6 nS per cross-section

GSM_long = @(x) linf(11.194e6, 4.9751e6, x); % orig
GSM_long = @(x) linf(111.94e6, 49.751e6, x);

resistors.RSM_long = ...
    { 'name', 'RSM_long', ...          % Scala Media
        'special', 'longitudinal', ...
        'ref_value', 1, ...
        'dep', {{'xpos'}}, ...
        'dep_fun', {{GSM_long}}, ...
        'dep_fun_args', {{{'xpos'}}}, ...
    };

GStV_long = @(x) linf(1e6, 1e6, x); % orig
% GStV_long = @(x) linf(10e6, 10e6, x);

resistors.RStV_long = ...
    { 'name', 'RStV_long', ...          % Stria Vascularis
        'special', 'longitudinal', ...
        'ref_value', 1, ...
        'dep', {{'xpos'}}, ...
        'dep_fun', {{GStV_long}}, ...
        'dep_fun_args', {{{'xpos'}}}, ...
    };

% SPIRAL LIMBUS
%     = R7 in Strelioff
GSL_long = @(x) linf(1e6, 1e6, x);
resistors.RSL_long = ...
    { 'name', 'RSL_long', ...
        'special', 'longitudinal', ...
        'ref_value', 1, ...
        'dep', {{'xpos'}}, ...
        'dep_fun', {{GSL_long}}, ...
        'dep_fun_args', {{{'xpos'}}}, ...
    };


% ORGAN OF CORTI
%     = R10 in Strelioff
% Strelioff 1973 has 200 - 100 kOhm per mm of cros-section
%   - our cochlea is 33.5 mm long
%     with 3000 cross-sections

% in nS:
% R1 = 1e9 / (200e3 * 33.5 / 3000)
%    = 0.44776e6 nS per cross-section
% R2 = 1e9 / (100e3 * 33.5 / 3000) 
%    = 0.89552e6 nS per cross-section

GOC_long = @(x) linf(0.44776e6, 0.89552e6, x); % orig
GOC_long = @(x) linf(4.4776e6, 8.9552e6, x);

resistors.ROC_long = ...
    { 'name', 'ROC_long', ...          % overall Organ of Corti resistance (of the cross sections)
        'special', 'longitudinal', ...
        'ref_value', 1, ...
        'dep', {{'xpos'}}, ...
        'dep_fun', {{GOC_long}}, ...
        'dep_fun_args', {{{'xpos'}}}, ...
    };

% SCALA VESTIBULI
%     = R8 in Strelioff
% Strelioff 1973 has 0.3 - 5.5 kOhm per mm of cros-section
%   - our cochlea is 33.5 mm long
%     with 3000 cross-sections

% in nS:
% R1 = 1e9 / (0.3e3 * 33.5 / 3000)
%    = 298.51e6 nS per cross-section
% R2 = 1e9 / (5.5e3 * 33.5 / 3000) 
%    = 16.282e6 nS per cross-section

GSV_long = @(x) linf(298.51e6, 16.282e6, x);

resistors.RSV_long = ...
    { 'name', 'RSV_long', ...
        'special', 'longitudinal', ...
        'ref_value', 1, ...
        'dep', {{'xpos'}}, ...
        'dep_fun', {{GSV_long}}, ...
        'dep_fun_args', {{{'xpos'}}}, ...
    };

% SCALA TYMPANI
%     = R11 in Strelioff
% Strelioff 1973 has 1 - 14 kOhm per mm of cros-section
%   - our cochlea is 33.5 mm long
%     with 3000 cross-sections

% in nS:
% R1 = 1e9 / (1e3 * 33.5 / 3000)
%    = 89.552e6 nS per cross-section
% R2 = 1e9 / (14e3 * 33.5 / 3000) 
%    = 6.3966e6 nS per cross-section

GST_long = @(x) linf(89.552e6, 6.3966e6, x);

resistors.RST_long = ...
    { 'name', 'RST_long', ...
        'special', 'longitudinal', ...
        'ref_value', 1, ...
        'dep', {{'xpos'}}, ...
        'dep_fun', {{GST_long}}, ...
        'dep_fun_args', {{{'xpos'}}}, ...
    };

%% Capacitors

capacitance_si_unit = 'F';
capacitance_unit = 'pF';
capacitors = struct( ...
    'CStV', struct( ...
        'name', 'CStV', ...          % Stria Vascularis
        'ref_value', 500 ...
    ));

CAI.name = 'CAI';                   % IHC, Apical
CAI.ref_value = 1;
CBI.name = 'CBI';                   % IHC, Basal
CBI.ref_value = 1;

CAO.name = 'CAO';                   % OHC, Apical
CAO.ref_value = num_ohc_per_cs;
CBO.name = 'CBO';                   % OHC, Basal
CBO.ref_value = num_ohc_per_cs;


capacitors.CAI = CAI;
capacitors.CBI = CBI;

capacitors.CAO = CAO;
capacitors.CBO = CBO;

% epsilon_0 = 8.854e-12; % F/m
epsilon_0 = 8.854; % pF/m

% Some data are from
% Arndt J. Duvall, III: Reissner's Membrane An Ultrastructural Study 1967

RM_width = 500e-6;   % m (my guess)
RM_thickness = 3e-6; % m [1.7 - 5.1 um] 
RM_length = 33.5e-3; % m (my guess)

CRM = epsilon_0 * RM_width * RM_length / RM_thickness;

CRM = CRM / 3000; % scaling

capacitors.CRM = struct( ...
        'name', 'CRM', ...
        'ref_value', CRM ...
    );

% BASE 0.08–0.16 mm
% APEX 0.42–0.65 mm
BM_width = 500e-6;   % m (my guess)
BM_thickness = 0.7e-6; % m [0.55 - 1.16 um] 
BM_length = 33.5e-3; % m (my guess)

CBM = epsilon_0 * BM_width * BM_length / BM_thickness;

CBM = CBM / 3000; % scaling

capacitors.CBM = struct( ...
        'name', 'CBM', ...
        'ref_value', CBM ...
    );

 

%     { 'name', 'CAO', ...          % OHC, Apical
%         'ref_value', n, ...
%         'dep', {{'xpos'}}, ...
%         'dep_fun', {{OHC_capacitance_apical}}, ...
%     }, ...
%     { 'name', 'CBO', ...          % OHC, Basal
%         'ref_value', n, ...
%         'dep', {{'xpos'}}, ...
%         'dep_fun', {{OHC_capacitance_basal}}, ...
%     }, ...

%% Voltage and Current sources

voltage_si_unit = 'V';
voltage_unit = 'mV';
vsources = { ...
    { 'name', 'VStV', ...          % endocochlear potential generated by Stria Vascularis
        ...'ref_value', Vep, ...
        'dep', {{'xpos'}}, ...
            'dep_fun', {{Vep}}, ...
    }, ...
    { 'name', 'VI', ...       % reversial K+ pot. between IHC and perilymph
        ...'ref_value', EK_IHC, ...
        'dep', {{'xpos'}}, ...
            'dep_fun', {{EK_IHC}}, ...
    }, ...
    { 'name', 'VO', ...       % reversial K+ pot. between OHC and perilymph
        ...'ref_value', EK_OHC, ...
        'dep', {{'xpos'}}, ...
            'dep_fun', {{EK_OHC}}, ...
    }, ...
    { 'name', 'VIapical', ... % reversial K+ pot. between IHC and endolymph
        'ref_value', 0, ...   % we include it for the ease of measuring MT current
    }, ...
    { 'name', 'VOapical', ... % reversial K+ pot. between OHC and endolymph
        'ref_value', 0, ...   % we include it for the ease of measuring MT current
    }, ...
    };

current_si_unit = 'A';
current_unit = 'A';
isources = {};

%% Connection
% node order is important when defining the connections

connection_0 = struct( ...
    'RAI', [2, 4], ...
    'CAI', [1, 4], ...
    'RBI', [4, 6], ...
    'CBI', [4, 8], ...
    ...
    'RAO', [3, 5], ...
    'CAO', [1, 5], ...
    'RBO', [5, 7], ...
    'CBO', [5, 9], ...
    ...
    'VIapical',  [1, 2], ...
    'VOapical',  [1, 3], ...
    ...
    'VI',  [6, 8], ...
    'VO',  [7, 9], ...
    ...
    'VStV', [1, 10], ... order 'flipped' on purpose
    'CStV', [0, 1], ...
    ...
    'RSL', [8, 0], ...
    'ROC', [9, 0], ...
    'RStV', [0, 10] ...
    ...
    ...'RSM_long', [1, NaN], ...
    ...'RSL_long', [8, NaN], ...
    ...'ROC_long', [9, NaN], ...
    ...'RStV_long', [10, NaN] ...
    ...'RStV_long', [8, NaN] ...
    );

connection_1 = struct( ...
    'RAI', [2, 4], ...
    'CAI', [1, 4], ...
    'RBI', [4, 6], ...
    'CBI', [4, 8], ...
    ...
    'RAO', [3, 5], ...
    'CAO', [1, 5], ...
    'RBO', [5, 7], ...
    'CBO', [5, 9], ...
    ...
    'VIapical',  [1, 2], ...
    'VOapical',  [1, 3], ...
    ...
    'VI',  [6, 8], ...
    'VO',  [7, 9], ...
    ...
    'VStV', [1, 10], ... order 'flipped' on purpose
    'CStV', [0, 1], ...
    ...
    'RSL', [8, 0], ...
    'ROC', [9, 0], ...
    'RStV', [0, 10], ...
    ...
    'RSM_long', [1, NaN], ...
    'RSL_long', [8, NaN], ...
    'ROC_long', [9, NaN], ...
    'RStV_long', [10, NaN] ...
    );

connection_2 = struct( ...
    'RAI', [2, 4], ...
    'CAI', [1, 4], ...
    'RBI', [4, 6], ...
    'CBI', [4, 8], ...
    ...
    'RAO', [3, 5], ...
    'CAO', [1, 5], ...
    'RBO', [5, 7], ...
    'CBO', [5, 9], ...
    ...
    'VIapical',  [1, 2], ...
    'VOapical',  [1, 3], ...
    ...
    'VI',  [6, 8], ...
    'VO',  [7, 9], ...
    ...
    'VStV', [1, 10], ... order 'flipped' on purpose
    'CStV', [0, 1], ...
    ...
    'RSL', [8, 0], ...
    'ROC', [9, 0], ...
    'RStV', [0, 10], ...
    ...
    'RRM', [1, 11], ... reisner membrane
    'RBM', [0, 12], ... basilar membrane
    ...
    'CRM', [1, 11], ... reisner membrane
    'CBM', [0, 12], ... basilar membrane
    ...
    'RSMSL', [8, 1], ... SM-SL
    'RSVSL', [8, 11], ... SV-SL
    'RSTSL', [8, 12], ... ST-SL
    ...
    ... Longitudinal Resistors
    'RSV_long', [11, NaN], ...
    'RST_long', [12, NaN], ...
    'RSM_long', [1, NaN], ...
    'RSL_long', [8, NaN], ...
    'ROC_long', [9, NaN], ...
    'RStV_long', [10, NaN] ...
    );

connection_3 = struct( ...
    'RAI', [2, 4], ...
    'CAI', [1, 4], ...
    ...'RBI', [4, 6], ...
    'RBI_leak', [4, 6], ...
    ...'RBI_fast', [4, 6], ...
    ...'RBI_slow', [4, 6], ...
    'CBI', [4, 8], ...
    ...
    'RAO', [3, 5], ...
    'CAO', [1, 5], ...
    ...'RBO', [5, 7], ...
    'RBO_leak', [5, 7], ...
    ...'RBO_fast', [5, 7], ...
    ...'RBO_slow', [5, 7], ...
    'CBO', [5, 9], ...
    ...
    'VIapical',  [1, 2], ...
    'VOapical',  [1, 3], ...
    ...
    'VI',  [6, 8], ...
    'VO',  [7, 9], ...
    ...
    'VStV', [1, 10], ... order 'flipped' on purpose
    'CStV', [0, 1], ...
    ...
    'RSL', [8, 0], ...
    'ROC', [9, 0], ...
    'RStV', [0, 10], ...
    ...
    'RRM', [1, 11], ... reisner membrane
    'RBM', [0, 12], ... basilar membrane
    ...
    'RSMSL', [8, 1], ... SM-SL
    'RSVSL', [8, 11], ... SV-SL
    'RSTSL', [8, 12], ... ST-SL
    ...
    'CRM', [1, 11], ... reisner membrane
    'CBM', [0, 12], ... basilar membrane
    ...
    ... Longitudinal Resistors
    'RSV_long', [11, NaN], ...
    'RST_long', [12, NaN], ...
    'RSM_long', [1, NaN], ...
    'RSL_long', [8, NaN], ...
    'ROC_long', [9, NaN], ...
    'RStV_long', [10, NaN] ...
    );

switch args.connection
    case 'v0'
        connection = connection_0;
    case 'mistrik'
        connection = connection_1;
    case 'v2'
        connection = connection_2;
    case 'v3'
        connection = connection_3;
        for i = 1:numel(mnaopt.IHC_basolateral_channels)
            rname = sprintf('RBI_%s', mnaopt.IHC_basolateral_channels(i).name);
            connection.(rname) = [4,6];
        end
        for i = 1:numel(mnaopt.OHC_basolateral_channels)
            rname = sprintf('RBO_%s', mnaopt.OHC_basolateral_channels(i).name);
            connection.(rname) = [5,7];
        end
    case 'v3r'
        connection = connection_3;
        for i = 1:numel(mnaopt.IHC_basolateral_channels)
            rname = sprintf('RBI_%s', mnaopt.IHC_basolateral_channels(i).name);
            connection.(rname) = [4,6];
        end
        for i = 1:numel(mnaopt.OHC_basolateral_channels)
            rname = sprintf('RBO_%s', mnaopt.OHC_basolateral_channels(i).name);
            connection.(rname) = [5,7];
        end
        % remove longitudinal connections
        elements = fieldnames(connection);
        for i = 1:numel(elements)
            if regexp(elements{i}, '.*_long')
                connection = rmfield(connection, elements{i});
            end
        end

    case {'v0e', 'v1e'}

        switch args.connection
            case 'v0e'
                connection = connection_0;
            case 'v1e'
                connection = connection_1;
        end

        connection = rmfield(connection, 'RBI');
        connection = rmfield(connection, 'RBO');

        connection.RBI_leak = [4,6];
        connection.RBO_leak = [5,7];

        for i = 1:numel(mnaopt.IHC_basolateral_channels)
            rname = sprintf('RBI_%s', mnaopt.IHC_basolateral_channels(i).name);
            connection.(rname) = [4,6];
        end
        for i = 1:numel(mnaopt.OHC_basolateral_channels)
            rname = sprintf('RBO_%s', mnaopt.OHC_basolateral_channels(i).name);
            connection.(rname) = [5,7];
        end
    otherwise
        error('Unknown connection %s', args.connection)
end

% connection = struct( ...
%     'RAI', [2, 4], ...
%     'CAI', [1, 4], ...
%     'RBI', [4, 6], ...
%     'CBI', [4, 8], ...
%     ...
%     'RAO', [3, 5], ...
%     'CAO', [1, 5], ...
%     'RBO', [5, 7], ...
%     'CBO', [5, 9], ...
%     ...
%     'VIapical',  [1, 2], ...
%     'VOapical',  [1, 3], ...
%     ...
%     'VI',  [6, 8], ...
%     'VO',  [7, 9], ...
%     ...
%     'VSV', [1, 10], ...
%     'CSV', [1, 0], ...
%     ...
%     'RStV', [10, 0], ...
%     'RSL', [8, 0], ...
%     'ROC', [9, 0], ...
%     ...
%     ... Longitudinal Resistors
%     'RSM_long', [1, NaN], ...
%     'RStV_long', [10, NaN], ...
%     'RSL_long', [8, NaN], ...
%     'ROC_long', [9, NaN] ...
%     );

% Old version of the connection excluding the MET batteries
% connection = struct( ...
%     'RAI', [1, 2], ...
%     'CAI', [1, 2], ...
%     'RBI', [2, 4], ...
%     'CBI', [2, 6], ...
%     ...
%     'RAO', [1, 3], ...
%     'CAO', [1, 3], ...
%     'RBO', [3, 5], ...
%     'CBO', [3, 7], ...
%     ...
%     'VSV', [1, 8], ...
%     'CSV', [1, 0], ...
%     ...
%     'RStV', [8, 0], ...
%     'RSL', [6, 0], ...
%     'ROC', [7, 0], ...
%     ...
%     ... Longitudinal Resistors
%     'RStV_long', [10, NaN], ...
%     'RSL_long', [8, NaN], ...
%     'ROC_long', [9, NaN] ...
%     );


%%

circuit = Circuit();

% -------------------------------------------------------------------------
% RESISTORS

k = Unit.conversionConstant(conductance_unit, simulation_units.conductance);

fnresistors = fieldnames(resistors);
for i = 1:numel(fnresistors)
    name = fnresistors{i};
    el = CircuitElement('type', 'resistor', resistors.(name){:});
    
    if ~isfield(connection, el.name)
        warning('Element %s defined but not used in connections!', el.name);
        continue
    end
    
    el.node1 = connection.(el.name)(1);
    el.node2 = connection.(el.name)(2);
    
    el.ref_value = el.ref_value * k;
    
    el.unit = simulation_units.conductance;
    el.si_unit = conductance_si_unit;
    
    circuit.add_element(el);
end

% -------------------------------------------------------------------------
% CAPACITORS

k = Unit.conversionConstant(capacitance_unit, simulation_units.capacitance);

fncapacitors = fieldnames(capacitors);
for i = 1:numel(fncapacitors)
    name = fncapacitors{i};
    p = namedargs2cell(capacitors.(name));
    el = CircuitElement('type', 'capacitor', p{:});
    
    if ~isfield(connection, el.name)
        warning('Element %s defined but not used in connections!', el.name);
        continue
    end
    
    el.node1 = connection.(el.name)(1);
    el.node2 = connection.(el.name)(2);
    
    el.ref_value = el.ref_value * k;
    
    el.unit = simulation_units.capacitance;
    el.si_unit = capacitance_si_unit;
    
    circuit.add_element(el);
end

% -------------------------------------------------------------------------
% VSOURCES

k = Unit.conversionConstant(voltage_unit, simulation_units.voltage);

for i = 1:numel(vsources)
    el = CircuitElement('type', 'vsource', vsources{i}{:});
    
    if ~isfield(connection, el.name)
        warning('Element %s defined but not used in connections!', el.name);
        continue
    end
    
    el.node1 = connection.(el.name)(1);
    el.node2 = connection.(el.name)(2);
    
    el.ref_value = el.ref_value * k;    
    
    el.unit = simulation_units.voltage;
    el.si_unit = voltage_si_unit;
    
    circuit.add_element(el);
end

% -------------------------------------------------------------------------
% ISOURCES

k = Unit.conversionConstant(current_unit, simulation_units.current);

for i = 1:numel(isources)
    el = CircuitElement('type', 'isource', isources{i}{:});
    
    if ~isfield(connection, el.name)
        warning('Element %s defined but not used in connections!', el.name);
        continue
    end
    
    el.node1 = connection.(el.name)(1);
    el.node2 = connection.(el.name)(2);
    
    el.ref_value = el.ref_value * k;
    
    el.unit = simulation_units.current;
    el.si_unit = current_si_unit;
    
    circuit.add_element(el);
end

%% Check circuit

enames = fieldnames(connection);
for i = 1:numel(enames)
    if isempty(circuit.get_element_by_name(enames{i}))
        error('Element %s not found in circuit but used in connections!', enames{i})
    end
end

%%

    function dep = replace_dependance(FROM, TO, dep)
        for ii = 1:numel(dep)
            if strcmp(dep{ii}, FROM)
                dep{ii} = TO;
            end
        end
    end


end
