function [circuit] = ME_circuit_PBLL(simulation_units, args)
%ME_CIRCUIT_PBLL 
arguments
    simulation_units
    args.UpdatedParameters = struct()
    args.plotflag (1,1) logical = false
end

units = struct();

units.conductance = 'S';
units.inductance = 'mH';
units.capacitance = 'uF';
units.voltage = 'mV';
units.current = 'A';

%%

t_1 = 1675; % 1/(dB^2 F)
t_2 = 33000; % 1/(dB^2 F)

p_ts = 0.2; % Pa
% p_t = 10^(L/20)*p_0;
p_0 = 20e-6; % uPa


LL = 80:1:120;
Cst = zeros(size(LL));
for i = 1:numel(LL)
    p_t = 10^(LL(i)/20)*p_0;
    L_ts = 20 * log10(p_t/p_ts);

    Cst(i) = 1e6/(t_1*L_ts^2 + t_2*L_ts); % uF
end

if args.plotflag == true
    figure
    plot(LL, Cst);
    xlabel('Level [dB SPL]')
    ylabel(sprintf('C_{st} [%s]', units.capacitance))
    title('Acoustic reflex')
end

%%

r_1 = 72;   % Ohm
r_2 = -251; % Ohm
r_3 = 442;  % Ohm

r_e = 0.266;

LL = 0:1:160;
Rla = zeros(size(LL));
for i = 1:numel(LL)
    p_t(i) = 10^(LL(i)/20)*p_0;
    alpha_t = p_t(i);

    Rla(i) = r_1 * exp(alpha_t^r_e) + r_2*alpha_t + r_3; % ??? nefunguje
    Rla(i) = r_1 * alpha_t^r_e + r_2*alpha_t + r_3; % ??? nefunguje
end

if args.plotflag == true
    figure
    plot(LL, Rla);
    xlabel('Level [dB SPL]')
    ylabel('R_{la} [Ohm]')
    title('Annular ligament')
end

%%

c_1 = -3.33e-2; % uF
c_2 = 4.64e-4;  % uF
c_3 = 0.54;     % uF

c_e = 0.174;

LL = 0:1:160;
Cla = zeros(size(LL));
for i = 1:numel(LL)
    p_t(i) = 10^(LL(i)/20)*p_0;
    alpha_t = p_t(i);

    Cla(i) = c_1*exp(alpha_t^c_e) + c_2*alpha_t + c_3;
end

if args.plotflag == true
%     figure
%     plot(p_t, Cla);
    figure
    plot(LL, Cla);
    xlabel('Level [dB SPL]')
    ylabel(sprintf('C_{la} [%s]', units.capacitance))
    title('Annular ligament')
end


%%

resistors = { ...
    { 'name', 'Rcm', ...
        'ref_value', 1/420, ...
    }, ...
    { 'name', 'Ra', ...
        'ref_value', 1/20, ...
    }, ...
    { 'name', 'Rti1', ...
        'ref_value', 1/200, ...
    }, ...
    { 'name', 'Rti2', ...
        'ref_value', 1/105, ...
    }, ...
    { 'name', 'Rti3', ...
        'ref_value', 1/12500, ...
    }, ...
    { 'name', 'Rte', ...
        'ref_value', 1/65, ...
    }, ...
    { 'name', 'Ris', ...
        'ref_value', 1/170, ...
    }, ...
    { 'name', 'Rla', ...
        'ref_value', 1/r_3, ...
    }, ...
    { 'name', 'Rco', ...
        'ref_value', 1/1211, ...
    }, ...
    { 'name', 'Rh', ...
        'ref_value', 1/850, ...
    }, ...
    };

inductors  = { ...
    { 'name', 'La', ...
        'ref_value', 12, ...
    }, ...
    { 'name', 'Lti', ...
        'ref_value', 15, ...
    }, ...
    { 'name', 'Lte', ...
        'ref_value', 40, ...
    }, ...
    { 'name', 'Ls', ...
        'ref_value', 8, ...
    }, ...
    { 'name', 'Lv', ...
        'ref_value', 21, ...
    }, ...
    { 'name', 'Lh', ...
        'ref_value', 150, ...
    }, ...    
    };

capacitors = { ...
    { 'name', 'Ccp', ...
        'ref_value', 3.6, ...
    }, ...
    { 'name', 'Ccm', ...
        'ref_value', 0.35, ...
    }, ...
    { 'name', 'Cte', ...
        'ref_value', 1.4, ...
    }, ...
    { 'name', 'Cti1', ...
        'ref_value', 0.5, ...
    }, ...
    { 'name', 'Cti2', ...
        'ref_value', 0.3, ...
    }, ...
    { 'name', 'Cti3', ...
        'ref_value', 0.2, ...
    }, ...
    { 'name', 'Cis', ...
        'ref_value', 0.03, ...
    }, ...
    { 'name', 'Cst', ...
        'ref_value', 2, ...
    }, ...
    { 'name', 'Cla', ...
        'ref_value', c_3, ...
    }, ...
    { 'name', 'Cparas1', ...
        'ref_value', 0.001, ...
        ... NOTE: the parasitic capacitor is included so that the DAE has 
        ... index = 1, and therefore can be directly solved by ode15s.
        ... The value has to be low enough not to affect the filtering
        ... properties. Testing suggests 0.1 uF is too high, the filter 
        ... behaves completely differently at f > 2 kHz, 0.01 uf already
        ... much better, but still different from 0.001 uF. The value
        ... 0.0001 uF shows practically no difference, so not used.
    }, ...
    };

vsources = { ...
    { 'name', 'Vt', ...
        'ref_value', 1, ... this value is scaled by pressure
    }, ...
    };

% vsources = {};

isources = {};

connection = struct( ...
    'Cparas1', [14,0], ... parasitic capacitor
    'Vt',   [0, 1], ...
    'Rcm',  [1, 2], ...
    'Ccm',  [1, 2], ...
    'La',   [1, 3], ...
    'Ccp',  [3, 4], ...
    'Ra',   [4, 2], ...
    'Rti1', [2, 5], ...
    'Cti1', [5, 6], ...
    'Cti2', [6, 7], ...
    'Rti2', [7, 8], ...
    'Rti3', [8, 0], ...
    'Lti',  [6, 8], ...
    'Cti3', [8, 0], ...
    'Cte',  [2, 9], ...
    'Lte',  [9, 10], ...
    'Rte',  [10, 11], ...
    'Cis',  [11, 12], ...
    'Ris',  [12, 0], ...
    'Ls',   [11, 13], ...
    'Cst',  [13, 14], ...
    'Rla',  [14, 15], ...
    'Cla',  [15, 16], ...
    'Lv',   [16, 17], ...
    'Rco',  [17, 0], ...
    'Rh',   [17, 18], ...
    'Lh',   [18, 0] ...
    );

circuit = generate_circuit( connection, ...
    resistors, inductors, capacitors, vsources, isources, ...
    units, simulation_units);


% update parameters if requested

% circuit.get_element_by_name('Lh').ref_value

keys = fieldnames(args.UpdatedParameters);
for i = 1:numel(keys)
    key = keys{i};
    val = args.UpdatedParameters.(key);
    
    if any(strcmp(key, {'Amplitude', 'Frequency'}))
        % do nothing
    else
        
        circuit.get_element_by_name(key).ref_value = val;
                
    end
end

% circuit.get_element_by_name('Lh').ref_value

end

